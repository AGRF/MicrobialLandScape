# Load required libraries
library(shiny)
library(shinyjs)
library(bslib)
library(randomForest)
library(dplyr)
library(DT)
library(plotly)
library(leaflet)
library(ggrain)
library(vegan)
library(ComplexHeatmap)
library(uwot)
options(scipen = 999)

# Set working directory and load data
mycolors <<- readRDS("www/mycolors.rds");
color_columns  = NULL;
color_columns2 = NULL;

agrf <- bs_theme(version=5, bootswatch="spacelab", tab_font_size = "36px") %>%   #bootswatch="cosmo"
  bs_add_rules(list(sass::sass_file("www/bootstrap.scss")))

# Define UI
ui <- fluidPage(
  theme = agrf,
  useShinyjs(),

  
  titlePanel(tags$h6(""), windowTitle = "Microbial Land Scape"),    
  
  # Add AGRF banner at the top
  div(
    style = "background-image: url('agrfwebbanner.png'); background-size: cover; background-position: center; height: 90px; position: relative;",
    div(
      style = "display: flex; align-items: center; justify-content: space-between; position: absolute; top: 20px; left: 0px; right: 0px; bottom: 5px;",
      div(
        style = "text-align: left; border: 1px solid #ccc; padding: 6px 25px 6px 20px; border-radius: 5px; margin-bottom: 15px;",
        p(
          style = "font-size: 8px;  margin: 0;", # Adjust font size here
          strong("Contact our Customer Care Team:"),
          br(),
          "Freecall 1300 247 301",
          br(),
          "Phone +61 3 9321 3700",
          br(),
          a("CustomerCare@agrf.org.au", href = "mailto:CustomerCare@agrf.org.au"),
          br(),
          a("www.agrf.org.au", href = "https://www.agrf.org.au")
        )
      ),
      div(
        style = "position: relative;",
        a(
          style = "position: absolute; top: -50px; right: 10px; opacity: 0.8;",
          href = "https://agrf.org.au", target = "_blank",
          img(src = "agrflogo_big.png", width = "150px", height = "auto") # Adjust logo size here
        )
      )
    )
  ),
  # Move tabPanel outside navbarPage
  navbarPage(
    title = tags$span(imageOutput("logo", height = "8", inline = FALSE), " - ", style = "color: #eeeeee; font-size: 2px; font-weight: regular;"),
    tabPanel("Predictions",
             sidebarLayout(
               sidebarPanel(
                  conditionalPanel(
                   condition = "!output.umap_plot",
                       fileInput("file", "Upload TSV File"),
                       h5("Click the button below to perform a prediction using the built-in test dataset. Alternatively, you can upload your own data in a TSV file generated by the AGRF DivPro pipeline. For the upload, please use the bacterial relative abundance file from the Results folder named: silva_rel-table-7.tsv."),
                       actionButton("predictBtn", "Predict with randomForest"),
                       uiOutput("credits_text"),
                       div(id = "spinner", class = "loader", style = "display: none;"),
                       img(id = "decor2_image",src = "decor2.png", width = "100%", height = "auto")
                  ),
                  conditionalPanel(
                     condition = "output.umap_plot",
                         uiOutput("heatmap_text"),
                         plotOutput("heatmap_plot", height = 600),
                   ),
                  conditionalPanel(
                    condition = "output.umap_plot",
                      br(),
                      img(src = "decor3.png", width = "100%", height = "auto"),
                      br()
                  )
               ),
               mainPanel(
                 uiOutput("umap1_text"),
                 conditionalPanel(
                   condition = "output.umap_plot",
                   fluidRow(
                     
                       column(3, div(
                         style = "padding: 0px;",
                         tags$label("Color by:", style = "font-size: 10px;"),
                         selectInput("color_by", NULL, choices = color_columns, width = "100%")  
                       )),                     
                       column(3, div(
                         style = "padding: 4px;",
                         tags$label("Number of Neighbors", style = "font-size: 10px;"),
                         numericInput("n_neighbors", NULL, value = 2, width = "100px")  
                       )),
                       column(3, div(
                         style = "padding: 4px;",
                         tags$label("Local Connectivity", style = "font-size: 10px;"),
                         numericInput("local_connectivity", NULL, value = 3, width = "100px")
                       )),
                       column(3, div(
                         style = "padding: 4px;",
                         tags$label("Minimum distance", style = "font-size: 10px;"),
                         numericInput("min_dist", NULL, value = 0.001, width = "120px")
                       ))
                   )
                 ),
                 plotlyOutput("umap_plot", height = 450),
                 br(),
                 hr(),
                 dataTableOutput("predictions")
               )
             )
    ),
    
    tabPanel("UMAP",
             sidebarLayout(
               sidebarPanel(
                 conditionalPanel(
                   condition = "typeof output.raincloud_plot1 === 'undefined' || output.raincloud_plot1 === null", 
                   h5("Select samples with [Lasso Select] or [Box Select] tool from umap figure on the right side. Hoover over top right corner of UMAP plot, then click, then pick the area on umap plot."),
                   img(src = "decor4.png", width = "100%", height = "auto")
                 ),
                 conditionalPanel(
                    condition = "output.raincloud_plot1 !== 'undefined' || output.raincloud_plot1 !== 'null'",  
                    h5("Selected vs unselected samples"),
                    plotOutput("raincloud_plot1", height = 450)
                 )
               ),
               mainPanel(
                 conditionalPanel(
                   condition = "!output.umap_plot",
                   tags$div(
                     style = "border: 1px solid gray; background-color: #f8f8f8; padding: 10px; border-radius: 5px;",
                     h4("Placeholder for UMAP figure:", style = "font-size: 18px; color: #777; margin-bottom: 10px;"),
                     h5("The UMAP figure here will be generated by using ONLY samples uploaded on the first tab [Prediction] or the default built-in testing dataset after clicking [Predict with Random forest]. The UMAP plot reflects actual bacterial abundance within each sample of the batch. Predicted values are not used as variables in the plot but only for coloring purposes as metadata."),
                     h5("The parameters on the left control the shape of the UMAP plot. These parameters are arbitrarily chosen and are likely to have the most significant effect on the embedding shape."),
                     h5( tags$b(" * Color by:                  "), tags$br(), " that column from the predicted metadata. Note that column will be used for rain cloud plot when you select dots on UMAP with lasso tool."),
                     h5( tags$b(" * UMAP: Number of Neighbors: "), tags$br(), " control local structure: how many samples sample considered per cluster. Integer must be more than 1. This usually effect how many main sample groups you can resolve with bacterial profiles."),
                     h5( tags$b(" * UMAP: Local Connectivity:  "), tags$br(), " how many connection each sample must have: minimum 1. That parameters usually linked with sample cohesivness and cluster area ther bigger number usually return much more spreaded structures."),
                     h5( tags$b(" * UMAP: Minimum distance:    "), tags$br(), " is a value between 0 and 1. This number affects the trade-off between local detail and global structure in the resulting embedding. If you want to explore the fine structure within clusters, a lower number may be preferable. If you are interested in understanding the global arrangement of data, a higher number can help."),
                     h5("For an explanation of UMAP hyperparameters, refer to this", a("blog", href = "https://pair-code.github.io/understanding-umap/"),  " written by Andy Coenen and Adam Pearce which you may find informative.")
                   )
                 ),
                 conditionalPanel(
                   condition = "output.umap_plot",
                   verbatimTextOutput("umap_main_diagnostic"),
                   plotlyOutput("umap_plot_main", height = 450),
                   
                   fluidRow(
                     column(2, div(
                       style = "padding: 0px;",
                       tags$label("Color by:", style = "font-size: 10px;"),
                       selectInput("Color", NULL, choices = color_columns2, width = "100%")  
                     )),                     
                     column(2, div(
                       style = "padding: 4px;",
                       tags$label("Number of Neighbors", style = "font-size: 10px;"),
                       numericInput("n_neighbors_m", NULL, value = 5, width = "100px")  
                     )),
                     column(2, div(
                       style = "padding: 4px;",
                       tags$label("Local Connectivity", style = "font-size: 10px;"),
                       numericInput("local_connectivity_m", NULL, value = 3, width = "100px")
                     )),
                     column(2, div(
                       style = "padding: 4px;",
                       tags$label("Minimum distance", style = "font-size: 10px;"),
                       numericInput("min_dist_m", NULL, value = 0.0001, width = "120px")
                     ))
                   ),
                   
                   DTOutput("table_umap_link")
               )
             )
      )
    ),
    
    tabPanel("AustralianMicrobiome",
             sidebarLayout(
               sidebarPanel(
                 conditionalPanel(
                   condition = "!output.bigmap",                
                     h5("Click on the button below to perform UMAP embedding with AMI soil subset data"),
                     actionButton("AMIembedBtn", "Embed with AMI"),
                   br(),
                   div(id = "spinner2", class = "loader", style = "display: none;"),
                   br(),                   
                   img(id = "decor1_image", src = "decor1.png", width = "100%", height = "auto")  
                 ),
                 conditionalPanel(
                   condition = "output.umap_plot_ami",
                      h5("Geographical map"),
                      div(id = "spinner2", class = "loader", style = "display: none;"),
                      leafletOutput("bigmap")
                 ),
                 uiOutput("batchdata_message"),
                 
                 h5("Selected samples (use Box or Lasso select tools from umap figure the top right corner)",  style = "color: gray;"),
                 tabsetPanel(
                   tabPanel("Environments", 
                            conditionalPanel(
                              condition = "typeof output.count_chart === 'undefined' || output.count_chart === null", 
                              div(style = "text-align: center;",
                                  h5(HTML("<span style='color: grey; font-size: smaller;'> . </span>")),                            
                                  img(src = "agrflogo_big.png", width = "80%", height = "auto")
                              )
                            ),
                            conditionalPanel(
                              condition = "typeof output.count_chart !== 'undefined' || output.count_chart !== null",                          
                              plotlyOutput("count_chart", height = 450)
                            )
                   ),
                   
                   tabPanel("Bacteria species", 
                            conditionalPanel(
                              condition = "typeof output.raincloud_plot === 'undefined' || output.raincloud_plot === null", 
                              div(style = "text-align: center;",
                                  h5(HTML("<span style='color: grey; font-size: smaller;'> . </span>")),    
                                  img(src = "agrflogo_big.png", width = "80%", height = "auto")
                              ),
                              h5(HTML("<span style='color: grey; font-size: smaller;'>Select samples with [Lasso Select] or [Box Select] tool from UMAP figure on the right side. Hover over the top right corner of UMAP plot, then click, then pick the area on UMAP plot.</span>"))
                            ),
                            conditionalPanel(
                              condition = "typeof output.raincloud_plot !== 'undefined' || output.raincloud_plot !== null", 
                              h5(HTML("<br> Number of detected bacterial species (OTUs) in Selected [<span style='background-color:  #009FDF; color: white;'>blue</span>] 
                                        vs unselected [<span style='background-color: #ED8B00; color: white;'>orange</span>] samples.")),
                              plotOutput("raincloud_plot", height = 450)
                            )
                   )
                 )
               ),
               mainPanel(
                 conditionalPanel(
                   condition = "!output.umap_plot_ami",
                   tags$div(
                     style = "border: 1px solid gray; background-color: #f8f8f8; padding: 10px; border-radius: 5px;",
                     h4("Australian Microbiome integration", style = "font-size: 18px; color: #777; margin-bottom: 10px;"),
                     a(
                       href = "https://www.australianmicrobiome.com",
                       img(
                         src = "Australian-Microbiome.jpg", 
                         style = "float: left; margin: 0 10px 10px 10px; width: 100%; max-width: 150px;"
                       )
                     ),
                     h5("Australian Microbiome Initiative is an Australian Government funded project to catalogue microbiome data and accompanied metadata gathered across various regions of Australia. To learn more about protocols, metadata methods, and raw data generation, visit the official Australian Microbiome Initiative website by clicking on the picture on the left."),
                     h5("The bacterial profiles from AMI samples were generated using the AGRF DivPro pipeline, will be merged with either a built-in test dataset or an uploaded dataset. The combined dataset will be plotted using UMAP and linked to a geographical map, where the coordinates for the test data are predicted. In this visualization, new batch (test) samples are represented with the usual position icon (a hot air balloon shape), while AMI samples are displayed as semi-transparent circles. You can use the UMAP plot to select clusters of nearby samples to see how they align on the geographical map and gather metadata for the selected samples in the linked interactive table. You can use rectangle or lasso selection tools for this purpose.")
                   )
                 ),
                conditionalPanel(
                     condition = "!output.umap_plot_ami",
                     tags$br(),
                     tags$div(
                       style = "border: 1px solid gray; background-color: #f8f8f8; padding: 10px; border-radius: 5px;",
                       h4("NVIS and ALUM8 for environment labels", style = "font-size: 18px; color: #777; margin-bottom: 10px;"),
                       a(
                         href = "https://www.dcceew.gov.au/environment/land/native-vegetation/national-vegetation-information-system",
                         img(
                           src = "nvisv7thumb.jpg", 
                           style = "float: left; margin: 0 10px 10px 10px; width: 100%; max-width: 150px;"
                         )
                       ),
                       h5("The National Vegetation Information System (NVIS) version 7.0 (Nov 2024) was used to assign soil samples spatially to major vegetation group labels (MVG), as defined in the extant layer referencing Australiaâ€™s 2016 conditions. Visit the official NVIS website by clicking on the picture on the left for more details. MVG are broad categories of vegetation types used to classify and map Australia's natural and modified landscapes. MVGs represent major structural and floristic groupings of vegetation, such as rainforests, woodlands, grasslands, and shrublands, based on dominant plant species and environmental characteristics. These classifications provide a consistent framework for understanding vegetation distribution and support environmental planning, conservation, and management. Covering the entire Australian continent, MVGs reflect the diversity of ecosystems across various climates and geographies, enabling a comprehensive representation of the country's vegetation patterns."),
                       h5(
                         "A substantial portion of the soil microbiome samples (~30-40%) from the AMI dataset fell into areas categorized by NVIS7 as MVG class 'Human-Affected Non-Native Vegetation'. These samples were further classified using spatial information from the ",
                         a(
                           href = "https://www.agriculture.gov.au/abares/aclump/land-use/alum-classification",
                           "Australian Land Use and Management Classification Version 8 (ALUM8)"
                         ),
                         " database (October 2016). This spatial layer provided more granular insights into soil specimens collected from agricultural and urban areas."
                       )
                     )
                   ),                 

                 conditionalPanel(
                   condition = "output.umap_plot_ready",
                   plotlyOutput("umap_plot_ami", height = 450),
                   fluidRow(
                     column(2, div(
                       style = "padding: 4px;",
                       tags$label("Number of Neighbors", style = "font-size: 10px;"),
                       numericInput("n_neighbors_ami", NULL, value = 4, width = "100px")  
                     )),
                     column(2, div(
                       style = "padding: 4px;",
                       tags$label("Local Connectivity", style = "font-size: 10px;"),
                       numericInput("local_connectivity_ami", NULL, value = 8, width = "100px")
                     )),
                     column(2, div(
                       style = "padding: 4px;",
                       tags$label("Minimum distance", style = "font-size: 10px;"),
                       numericInput("min_dist_ami", NULL, value = 0.14, width = "120px")
                     ))
                   )
                 ),
               #),
               conditionalPanel(
                 condition = "output.table_umap_ami !== null",
                 fluidRow(
                   column(12, DTOutput("table_umap_ami"))
                 )
               )
               ) #main panel
             )
          ),

          tabPanel(
            "Sample report",
            sidebarLayout(
              sidebarPanel(
                selectInput(
                  "sample_id", 
                  "Select Sample ID", 
                  choices = NULL  # Dynamically populated in server
                ),
                uiOutput("dynamic_download_button"),  # Placeholder for dynamic button
                width = 5 
              ),
              mainPanel(
                h5("To make report files in this tab you have generate prediction values by clicking on predict button in the first tab
                and then embed you samples with AMI dataset on the third tab."),
                h5("To save individual sample report in HTML file, select sample id from dropdown
                and click on download button, when it will appered. In opened download menue select destination folder on your local disk. 
                Note it may take few seconds before file name for download appeared."),
                h5("The individual sample report will be a portable (single HTML) file with an interactive UMAP embedding. Please note that the parameters for the exported UMAP will match those selected in the AMI embedding tab. The report will also include the top 10 most similar samples from the AMI dataset, the top 10 bacteria displayed in a sunburst plot, and the top 3 classifier results for the most probable environments where sample was taken."),
                
                width = 6 
                
              )
            )
          ) 
  
  )
)

# Define server logic
server <- function(input, output, session) {
  shinyjs::useShinyjs();
  output$logo <- renderImage({
    list(src = "agrflogo.png",  width = "160px", height = "60px", alt = "logo")
  }, deleteFile = FALSE);
  
  color_columns  <- NULL;
  color_columns2 <- NULL;
  allpredictions <- NULL;
  mypredictions  <- reactiveVal(NULL);
  allredictions  <- reactiveVal(NULL);
  map_rendered   <- reactiveVal(FALSE)
  output$credits_text <- renderUI({
        HTML(paste("<hr>",
        "<h5><b> Credits: </b><ul>",
        "<li> AGRF Data Science team </li>",
        "<li> Lesley Gray     </li>",
        "<li> Rust Turakulov </li></ul></h5>",
        "<hr>"))
  });
  
  ###### Function to perform prediction for regression models
  performPrediction <- function(data) {
    rgrsnmodels <- c(
      "latitude.rfm.rds",
      "longitude.rfm.rds",
      "texture.rfm.rds",
      "gravel.rfm.rds",
      "ph.rfm.rds",
      "ph_solid_h2o.rfm.rds",
      "nitrate_nitrogen.rfm.rds",
      "organic_carbon.rfm.rds",
      "conductivity.rfm.rds"
#      "phosphorus_colwell.rfm.rds",
#      "potassium_colwell.rfm.rds",
#      "sulphur.rfm.rds",
#      "ammonium_nitrogen_wt.rfm.rds",
#      "exc_magnesium.rfm.rds"
    )
    
    total_models <- length(rgrsnmodels)
    progress <- 0
    
    rgsnresusts <- data.frame(Sample = colnames(data))
    
    withProgress(message = 'Predicting...', value = 0, {
      for (model_file in rgrsnmodels) {
        # Update progress
        incProgress(1/total_models, detail = paste("Regression model", progress + 1, "of", total_models))
        
        model <- readRDS(paste0("rfm_files/", model_file))
        missedasvs  <- setdiff(row.names(model$importance), row.names(data))
        empty_table <- data.frame(matrix(0, nrow = length(missedasvs), ncol = ncol(data)))
        rownames(empty_table) <- missedasvs
        colnames(empty_table) <- colnames(data)
        NOGAPTABLE <- rbind(data, empty_table)
        
        # Perform prediction
        rgsnresusts[[model_file]] <- predict(model, newdata = as.data.frame(t(NOGAPTABLE)));
        
        # Increment progress
        progress <- progress + 1
      }
    })
    
    colnames(rgsnresusts) <- gsub(".rfm.rds$|.rds$", "", colnames(rgsnresusts), ignore.case = TRUE, perl = TRUE);
    
    return(rgsnresusts)
  }
  
  # Function to perform prediction for classification models
  performPredictionClass <- function(data) {
    classmodels <- c(
      "RFM.Acacia_Shrublands.rds",
      "RFM.Eucalypt_Woodlands.rds",      
      "RFM.Eucalypt_Open_Forests.rds",
      "RFM.Eucalypt_Low_Open_Forests.rds",      
      "RFM.Eucalypt_Tall_Open_Forests.rds",
      "RFM.Hummock_Grasslands.rds",
      "RFM.Other_Grasslands_Herblands_Sedgelands_and_Rushlands.rds",
      "RFM.Rainforests_and_Vine_Thickets.rds",      
      "RFM.Other_Forests_and_Woodlands.rds",
      "RFM.Grazing_modified_pastures.rds",
      "RFM.Irrigated_cropping.rds",
      "RFM.Dryland_cropping.rds",
      "RFM.Mining_and_waste.rds",
      "RFM.Urban_intensive_uses.rds"
      
#     "RFM.Acacia_Forests_and_Woodlands.rds",
#     "RFM.Acacia_Open_Woodlands.rds",
#     "RFM.Casuarina_Forests_and_Woodlands.rds",
#     "RFM.cereals.ami.rds",
#     "RFM.Chenopod_Shrublands,_Samphire_Shrublands_and_Forblands.rds",
#     "RFM.Cleared,_non-native_vegetation,_buildings.rds",
#     "RFM.env_broad_scale.rds",
#     "RFM.Eucalypt_Open_Woodlands.rds",
#     "RFM.Eucalypt_Tall_Open_Forests.rds",
#     "RFM.Grasing_native.rds",
#     "RFM.Grazing_sown_pastures.rds",
#     "RFM.Heathlands.rds",
#     "RFM.Inland_aquatic_-_freshwater,_salt_lakes,_lagoons.rds",
#     "RFM.Low_Closed_Forests_and_Tall_Closed_Shrublands.rds",
#     "RFM.Mallee_Woodlands_and_Shrublands.rds",
#     "RFM.Melaleuca_Forests_and_Woodlands.rds",
#     "RFM.Naturally_bare_-_sand,_rock,_claypan,_mudflat.rds",
#     "RFM.Nuts.rds",
#     "RFM.Other_Open_Woodlands.rds",
#     "RFM.Pastures_and_crops_for_hay_and_silage.rds",
#     "RFM.sugar.ami.rds",
#     "RFM.Sugar_cane.rds",
#     "RFM.Tropical_Eucalypt_WoodlandsGrasslands.rds",
#     "RFM.Tropical_stone_fruit.rds",
#     "RFM.Tussock_Grasslands.rds",
#     "RFM.Winter_cereal.rds",
#     "RFM.Winter_legumes.rds",
#     "RFM.Winter_oilseeds.rds"                                  
    )
    
    total_cmodels <- length(classmodels)
    progress <- 0
    
    classresults <- data.frame(Sample = colnames(data))
    
    withProgress(message = 'Predicting...', value = 0, {
      for (model_file in classmodels) {
        # Update progress
        incProgress(1/total_cmodels, detail = paste("Classification model", progress + 1, "of", total_cmodels))
        
        model <- readRDS(paste0("rfm_files/", model_file))
        missedasvs  <- setdiff(row.names(model$importance), row.names(data))
        empty_table <- data.frame(matrix(0, nrow = length(missedasvs), ncol = ncol(data)))
        rownames(empty_table) <- missedasvs
        colnames(empty_table) <- colnames(data)
        NOGAPTABLE <- rbind(data, empty_table)
        
        # Perform prediction and extract probability for the prediction class
        probflattab  <- data.frame(predict(model, newdata = t(NOGAPTABLE), type="prob"))
        colnames(probflattab)[grep("YES", colnames(probflattab))] <- model_file; #windows and Unix library difference
        classresults <- cbind(classresults, probflattab);
        # Increment progress
        progress <- progress + 1
      }
    })
    
    colnames(classresults) <- gsub("^RFM.|.rfm.rds$|.rds$|,", "", colnames(classresults), ignore.case = TRUE, perl = TRUE);
    classresultsclean     <- classresults[, grep("UNKN|Unknown|OTHERS", colnames(classresults), ignore.case = TRUE, perl=T, invert = TRUE)];
    return(classresultsclean)
  }

  
  
  # Define server logic inside a function
  observeEvent(input$predictBtn, {
    shinyjs::show("spinner")
    shinyjs::hide("decor2_image")  
    
    # Load data
    if(is.null(input$file) || is.na(input$file$datapath)) {
#      clientdata <- read.csv("N3_silva_rel-table-7.csv", header = TRUE, row.names = 1)
       clientdata <- read.csv("PRJNA695356_NT_v3v4_silva_rel-table-7.csv", header = TRUE, row.names = 1)
       clientdata <- clientdata[, 1:8]; #Just eight samples for the quickness
    } else {
      clientdata <- read.csv(input$file$datapath, sep="\t", skip=1, header = TRUE, row.names = 1)
    }
    row.names(clientdata) <- gsub(";",  "_", row.names(clientdata))   ## Some conditioning of OTUs names
    row.names(clientdata) <- gsub("\\.", "", row.names(clientdata))   ## OTUs  derived  from  Silva  v138
    row.names(clientdata) <- gsub("\\W", "", row.names(clientdata))   ## Models were trained on that format
    batchdata <<- clientdata;
    
    # Perform prediction
    predictions       <- performPrediction(clientdata);
    predictionsclass  <- performPredictionClass(clientdata);
    allpredictions    <- merge(predictions, predictionsclass, by="Sample", all=TRUE);
    numeric_cols      <- sapply(allpredictions, is.numeric)
    allpredictions[, numeric_cols] <- round(allpredictions[, numeric_cols], digits=2);

    color_columns     <- colnames(allpredictions)[-1];
    color_columns2    <- colnames(allpredictions)[-1];
    updateSelectInput(session, "color_by",  choices = color_columns)    
    updateSelectInput(session, "Color", choices = color_columns2)
    
    mypredictions <<- allpredictions    # unpredictable with external RMD code so saving it as a file for markdown report
    mypredictions_tmpfile <<- tempfile(pattern = "mypredictions_", fileext = ".rds")
    saveRDS(allpredictions, file = mypredictions_tmpfile )
    print(paste("Predictions saved to:", mypredictions_tmpfile))
    
    umap_result <- reactive({
      umap_res <- uwot::umap(allpredictions[,-1], seed = 123,
                             metric = "cosine",
                             n_neighbors = input$n_neighbors,
                             local_connectivity = input$local_connectivity,
                             min_dist = input$min_dist )
      
      row.names(umap_res) <- allpredictions$Sample;
      colnames(umap_res)  <- c("umap_x", "umap_y");
      umap.res <- merge(umap_res, allpredictions,
                        by.x = "row.names", by.y = "Sample", all.x = TRUE);
      colnames(umap.res)[1] <- "Sample";
      umap.res;
    });
    
    output$umap_plot <- renderPlotly({
      req(umap_result()) 
      req(input$color_by) 
      selected_variable <- input$color_by
      
      pumap <- plot_ly(umap_result(), x = ~umap_x, y = ~umap_y, color = paste(selected_variable), colors="Blues", source = "umap_plot" ) %>%    
        add_markers(
          color = ~.data[[input$color_by]],
          text  = ~paste("Sample: " , .data$Sample),
          size  = 15
        )%>%
        layout(
          title = list(
            text = "UMAP embedding on predicted values", 
            x = 0,                # Align to the left (0 is fully left, 1 is fully right)
            y = 1,                # Move the title to the top
            xanchor = "left",     # Anchor the title to the left
            font = list(size = 10, color = "darkgray") 
          ),
          legend = list(title = list(text = " ")))     
      
      pumap
      
    })    

    ### the second tab bacterial abundance UMAP ################################   
    umap_main <- reactive({
      umap_bac <- uwot::umap(t(clientdata), seed = 123,
                             metric = "cosine",
                             n_neighbors = input$n_neighbors_m,
                             local_connectivity = input$local_connectivity_m,
                             min_dist = input$min_dist_m )
      
      colnames(umap_bac) <- c("umap_x", "umap_y")
      rownames(umap_bac) <- colnames(clientdata)
      umap.bac <- data.frame(Sample = rownames(umap_bac), umap_bac)
      umap.bac <- merge(umap.bac, allpredictions, by = "Sample", all.x = TRUE)

            umap.bac
            
    });
    
    output$umap_plot_main <- renderPlotly({
      req(umap_main())  # Ensure umap_main is not NULL
      req(input$Color) 
      selected_variable2 <- input$Color
      pumapm <- plot_ly(umap_main(), x = ~umap_x, y = ~umap_y, color = selected_variable2, colors="Blues", source = "umap_main") %>%
        add_markers(
          color = ~.data[[input$Color]],
          text  = ~paste("Sample: " , .data$Sample), 
          size  = 15 
        ) %>%
        layout(
          title = list(
            text = "UMAP embedding on bacterial abundance values  <br> made on test batch samples only", 
            x = 0,                # Align to the left (0 is fully left, 1 is fully right)
            y = 0.95,             # Move a bit down to fit second line
            xanchor = "left",     # Anchor the title to the left
            font = list(size = 10, color = "darkgray")
          ),
          legend = list(title = list(text = " "))
        )
      
      # Register the 'plotly_selected' event with the plot
      event_register(pumapm, "plotly_selected")
      
      pumapm
      
    });
    
    observeEvent(event_data("plotly_selected", source = "umap_main"), {
      selected_data <- event_data("plotly_selected", source = "umap_main")
      
      if (!is.null(selected_data)) {
        selected_x <- selected_data$x
        selected_y <- selected_data$y
        
        # Find rows in umap_main() that match the selected x and y coordinates
        selected_samples <- umap_main() %>%
          filter(umap_x %in% selected_x, umap_y %in% selected_y) %>%
          select(Sample) %>%
          pull()
        
        filtered_metadata <- umap_main() %>%
          filter(Sample %in% selected_samples)
        

         output$table_umap_link <- renderDT({
           datatable(filtered_metadata,
                     caption = 'Table with prediction on selected samples',
                     extensions = 'Buttons',
                     options = list(autoWidth = FALSE,
                                    lengthMenu = c(5, 25, 50, 100),
                                    scrollY = TRUE,
                                    scrollX = TRUE,
                                    columnDefs = list(list(visible = FALSE, targets = c(5:10))),
                                    paging = TRUE,
                                    searching = TRUE,
                                    fixedColumns = TRUE,
                                    ordering = TRUE,
                                    dom = 'Blfrtip',
                                    buttons = c('colvis', 'copy', 'csv', 'excel'))) %>%
             formatStyle(columns = c(1, 2), fontSize = '75%')
         })
         
         ########### HISTOGRAMS :: raincloud :: boxplot
         raintable       <- as.data.frame(allpredictions[, c("Sample", as.character(input$Color))]);
         raintable$Group <- "Not selected";
         raintable[which(raintable$Sample %in% selected_samples) , "Group"] <- "Selected";
         
         output$raincloud_plot1 <- renderPlot({
           ggplot(raintable, aes_string(x=1, y=input$Color, fill = "Group", color = "Group")) +
             geom_rain(alpha = .5, rain.side = 'l',
                       boxplot.args = list(color = "black", outlier.shape = NA),
                       boxplot.args.pos = list(
                         position = ggpp::position_dodgenudge(x = -0.1, width = 0.1), width = 0.1
                       ), size = 1.5) +
             theme_classic() +
             scale_fill_manual(values  = c("Selected" = "#ED8B00", "Not selected" = "#009FDF")) +
             scale_color_manual(values = c("Selected" = "#ED8B00", "Not selected" = "#009FDF")) +
             guides(fill = 'none', color = 'none');
            

         })
       }
      })
        
    ##################################end of interactive table and raincloud######

    # Render DT table
    output$predictions <- renderDataTable({
      datatable(
        allpredictions,
        caption = 'Prediction results of randomForest models, trained on AMI soil dataset with AMI, ALUM and NVIS metadata layers.',
        extensions = 'Buttons',
        options = list(autoWidth = FALSE,
                       lengthMenu = list(c(5, 10, 50, 100, -1), c('5', '10', '50', '100', 'Full view for export')),
                       scrollY = TRUE,
                       scrollX = TRUE,
                       columnDefs = list(list(visible = FALSE, targets = c(2,3,4, 8:15))), #c(2,3,4, 8:15))),
                       paging = TRUE,
                       searching = TRUE,
                       fixedColumns = TRUE,
                       ordering = TRUE,
                       dom = 'Blfrtip',
                       pageLength = 10, ## length of the table
                       buttons = list(
                         list(extend = 'colvis', text = 'Column Visibility'),
                         list(extend = 'collection', text = 'Export', 
                              buttons = list(
                                list(extend = 'copy',  filename = 'AGRF_MicrobialLandScape_predictions'),
                                list(extend = 'csv',   filename = 'AGRF_MicrobialLandScape_predictions'),
                                list(extend = 'excel', filename = 'AGRF_MicrobialLandScape_predictions'),
                                list(extend = 'pdf',   filename = 'AGRF_MicrobialLandScape_predictions')
                              ))
                       ))
      )
    })
    
    
    ## ComplexHeatmap
    shannonindex <- data.frame(alphadiv = round(diversity(t(clientdata), index = "shannon"),2))
    HEATMX <- merge(shannonindex, as.data.frame.matrix(predictions), by.x = "row.names", by.y = "Sample", all = TRUE)
    rownames(HEATMX) <- HEATMX$Row.names
    HEATMX$Row.names <- NULL
    max_shannon <- max(shannonindex$alphadiv)
    min_shannon <- min(shannonindex$alphadiv)
    # Adjust the scale of the Shannon index values
    scaled_alphadiv <- (HEATMX$alphadiv - min_shannon) / (max_shannon - min_shannon)
    shannon_annotation <- rowAnnotation(
      Shannon = anno_barplot(
        scaled_alphadiv, 
        bar_width = 0.7
      )
    )

    normalized_HEATMX <- apply(HEATMX, 2, function(x) (x - min(x)) / (max(x) - min(x)))    
    
    custom_palette <- colorRampPalette(c("white", "gray", "#009FDF"))
    col_fun <- custom_palette(9)
    
    ht <- Heatmap(
      as.matrix(normalized_HEATMX), 
      name = "Scaled Values for Predictions",
      col = col_fun,
      cluster_columns   = TRUE,
      show_row_dend     = TRUE, 
      show_column_dend  = TRUE,
      show_column_names = TRUE,
      show_row_names    = TRUE,
      heatmap_width     = unit(12, "cm"),
      heatmap_height    = unit(18, "cm"),
      right_annotation  = shannon_annotation,
      column_names_rot  = 45, 
      column_names_side = "bottom",
      heatmap_legend_param = list(direction = "vertical",  
                                  legend_height = unit(4, "cm"), 
                                  grid_width = unit(0.8, "cm"), 
                                  title_position = "leftcenter-rot"),
      column_title_rot = 90, 
      column_title_gp = gpar(fontsize = 24),
      row_names_gp    = gpar(fontsize = 8)
    )
    
    #draw(ht, heatmap_legend_side = "left", annotation_legend_side = "left")
    
    output$heatmap_plot <- renderPlot({
      draw(ht,
           heatmap_legend_side = "left",
           annotation_legend_side = "left",
           padding = unit(c(5, 15, 30, 10), "mm")  # Adjust margins (top, right, bottom, left)
      )
      
      if (!map_rendered()) {
           map_rendered(TRUE)
      }      
    })
    ########################################## end of heatmap
    
 
    ## Add text to the page after figure generated
    output$heatmap_text <- renderUI({
      if (map_rendered()) {
        h5("Heatmap of soil phys.chem properties predicted with randomForest models.")    
      }
    });

    # Hide spinner
     shinyjs::hide("spinner")    

  })
  
  output$umap1_text <- renderUI({
    if (map_rendered()) {
      h5("This UMAP figure visualizes sample groups based on table of the predicted values generated by randomForest models. It's not a direct mapping of bacterial profiles but an organized samples representation by using their predicted soil properties. Please note the umap_y and umap_x values do not have physical meaning those are projections from multidimesional space.");    
    }else{
      HTML(
        paste(
          "<h4 style='font-size: 16px; color: darkgrey;'>Workflow description</h4>",
          img(src = "randomForest_workflow.png", style = "display: block; margin-left: auto; margin-right: auto; width: 80%; max-width: 800px;  height: auto"),
          "<h5>The dataset used in this analysis comprises Fastq files obtained from the Bioplatforms Australia (BPA) data portal. These files contain publicly available soil 16S rDNA data, encompassing over 3,000 samples collected across various regions of Australia.</h5>",
          "<h5>Data Processing:</h5>",
          "<h5>The Fastq files were processed using the Australian Genome Research Facility (AGRF) DivPro pipeline. This pipeline generates a bacterial relative abundance matrix using the Silva 138 database.</h5>",
          "<h5>Metadata Integration:</h5>",
          "<h5>Metadata accompanying the Fastq files, compiled by the Australian Microbiome Initiative (AMI), was merged with the abundance matrix. This metadata includes essential parameters such as latitude, longitude, pH, water content, organic carbon, potassium, phosphorus, among others.</h5>",
          "<h5>Model Training:</h5>",
          "<h5>Random Forest Regression Models:  trained using the merged dataset to predict quantitative values such as latitude, longitude, pH, etc. These models utilize the microbial abundance data along with the accompanying metadata to predict the soil characteristics accurately.</h5>",
          "<h5>Random Forest Classification Models:  were developed to predict Major Vegetation Group (MVG) labels using the National Vegetation Information System (NVIS) overlay on the soil dataset. Additional classification labels were obtained from the Australian Land Usage Metadata (ALUM8) database. These models categorize soil samples into binary classes, distinguishing MVG group samples from all others.</h5>",
          "<h5>Model Outputs:</h5>",
          "<h5>The prediction scores provided in the output tables represent the confidence levels of the random forest models in assigning the respective classes or predicting quantitative values.</h5>",
          "<h5>This algorithmic approach enables the comprehensive analysis of soil microbiome data, integrating microbial abundance information with metadata and external classification systems. The trained models facilitate accurate predictions of soil characteristics and potential land usage suitability based on microbial profiles</h5>"
        )
      )
    }
  });

  #### End main UMAP tab with batch bacterial profiles ##################################################
  #### the third tab UMAP with AMI data-set integration #################################################   
  observeEvent(input$AMIembedBtn, {
    shinyjs::show("spinner2")
    shinyjs::hide("decor1_image")  

    output$batchdata_message <-  renderUI({
      HTML("")   # Empty at the start otherwise this text is below leaflet image
    });
    output$umap_plot_ready <- reactive({
      req(umap_main_ami())  # Ensure UMAP data is available
      TRUE  # Return TRUE when the plot is ready
    })
    outputOptions(output, "umap_plot_ready", suspendWhenHidden = FALSE);
    

    if( exists("mypredictions") ){
      withProgress(message = 'Processing AMI and the batch data: ', value = 0, {
        incProgress(0.1, detail = " Loading AMI dataset...")
#        amidataset  <- readRDS("rfm_files/meta_with_otus_ozcontinent_3202x8128.rds");
        amidataset  <<- readRDS("rfm_files/meta_with_otus_ozcontinent_3202x8128nvis7.rds");
        AMIMAX      <- t(amidataset[,-c(1:21)]);
        colnames( AMIMAX )    <- amidataset$ids;
        TWOTAB                <- merge(batchdata, AMIMAX, by="row.names", all=TRUE);
        row.names(TWOTAB)     <- TWOTAB$Row.names;
        TWOTAB                <- TWOTAB[,-1];
        TWOTAB[is.na(TWOTAB)] <- 0;
    
        ## Prepare data for the leaflet geographical coordinates
        incProgress(0.2, detail = " Preparing data for UMAP...")
        twotab <- merge(amidataset[,c("ids","sample_id","longitude","latitude","MVG_NAME.extant")],
                        t(TWOTAB), by.x="ids" , by.y="row.names", all=TRUE)
      
        ## Updating combined batch and ami metadata with predicted batch coordinates
        incProgress(0.3, detail = " Updating batch metadata...")
        for(msample in mypredictions$Sample){
          twotab[which(twotab$ids == msample), c("sample_id", "longitude","latitude", "MVG_NAME.extant")] <- 
          c("TestBatch", as.numeric(mypredictions[which(mypredictions$Sample== msample), c("longitude", "latitude")]), "TestBatch")
        }
        twotab$latitude  <- as.numeric(twotab$latitude);
        twotab$longitude <- as.numeric(twotab$longitude);
        
        
#        message("Start dimesionality reduction for merged AMI and batch dataset...");
        incProgress(0.4, detail = "Dimesionality reduction on merged data and UMAP...")
        std_devs        <- apply(twotab[, -(1:5)], 2, sd, na.rm = TRUE);
        top_cols        <- order(std_devs, decreasing = TRUE)[1:500]; ##Pick the number of the most variable bacteria 
        twotab          <<- twotab[, c(1:5, top_cols + 5)]; 

        umap_main_ami <- reactive({
          shinyjs::show("spinner2") 
          event_register(NULL, "plotly_selected")
          umap_ami <- uwot::umap(twotab[, -c(1:5)],    seed = 123,
                                 metric =              "cosine",
                                 n_neighbors =         input$n_neighbors_ami,   
                                 local_connectivity =  input$local_connectivity_ami,
                                 min_dist =            input$min_dist_ami )
          
          colnames(umap_ami)    <- c("umap_x", "umap_y");
          rownames(umap_ami)    <- twotab$ids;
          umap_ami              <- as.data.frame(umap_ami);
          umap_ami$ids          <- twotab$ids;
          umap_ami$sample_id    <- twotab$sample_id;
          umap_ami$Environment  <- as.factor(twotab$MVG_NAME.extant);
          umap_ami              <- umap_ami[,c("ids","sample_id","umap_x", "umap_y", "Environment")];
          
          return(umap_ami)
          
        });
#        message("Got UMAP coordinates in umap_main_ami...");
        incProgress(0.6, detail = "Rendering UMAP plot...");
        observe({
          req(umap_main_ami())
          umap_data     <-  as.data.frame(umap_main_ami());
          umap_data_ami <<- umap_data  ; ## For use in RMD report later
          
          missing_envs  <-  setdiff(unique(umap_data$Environment), names(mycolors));
          random_colors <-  setNames(rainbow(length(missing_envs)), missing_envs);
          mycolors      <-  c(mycolors, random_colors);
        
          output$umap_plot_ami <- renderPlotly({
            shinyjs::hide("spinner2")  
            req(umap_main_ami())  
#            message("Generating plotly for AMI umap...")
            
            umapami <- plot_ly(umap_data, x = ~umap_x, y = ~umap_y, color = ~Environment, colors=mycolors, source = "umapami") %>%
              add_markers(
                color = umap_data$Environment,
                text  = ~paste("Sample: ", row.names(umap_data)),
                size  = 12 
              ) %>%
              layout(
                title = list(
                  text = "UMAP embedding on bacterial abundance values<br>for batch data combined with AMI soil dataset", 
                  x = 0,                # Align to the left (0 is fully left, 1 is fully right)
                  y = 0.95,             # Move the title down to make it visible
                  xanchor = "left",     # Anchor the title to the left
                  font = list(size = 10, color = "darkgray") 
                ), 
                legend = list(title = list(text = " "))
              )
            # Register the 'plotly_selected' event with the plot
            event_register(umapami, "plotly_selected")
  
            return(umapami)
            
          })
        })
  
          ### Preparing leaflet data datasets
          incProgress(0.8, detail = "Rendering geographical map...");
          geobatch   <- as.data.frame(twotab[which(twotab$sample_id == "TestBatch"), c(1,3,4)]);
          geoami     <- as.data.frame(twotab[which(twotab$sample_id != "TestBatch"), c(1:5)]);
  
          # Reactive expression for umappicked
          umappicked <- reactive({
            selected_data <- event_data("plotly_selected", source = "umapami")
            
            if (!is.null(selected_data) && nrow(selected_data) > 0) {
              selected_x <- selected_data$x
              selected_y <- selected_data$y
              
              selected_samples <- umap_main_ami() %>%
                filter(umap_x %in% selected_x, umap_y %in% selected_y)
              
              selected_row_names <- rownames(selected_samples)
              
              umappicked_data <- geoami %>%
                filter(ids %in% selected_row_names);
              
              shinyjs::hide("spinner2") 
              
              return(umappicked_data)
            } else {
              return(geoami[FALSE, ])
              shinyjs::hide("spinner2") 
            }
            
          })
          
        # Rendering the leaflet map
          output$bigmap <- renderLeaflet({
            leaflet() %>%
              addTiles() %>%
              setView(lng = 133.775, lat = -25.2744, zoom = 4) %>%
              addMarkers(
                lng = as.numeric(geobatch$longitude),
                lat = as.numeric(geobatch$latitude),
                popup = paste(
                  "<b>Sample ID:</b> ", geobatch$ids, "<br>",
                  "<b>Coordinates(pred):</b> ", geobatch$latitude, " : ", geobatch$longitude
                )
              )%>%
              addCircleMarkers(
                data = geoami,
                lng = ~longitude,
                lat = ~latitude,
                popup = paste(
                  "<b>AMI Sample ID:</b> ", geoami$sample_id, "<br>",
                  "<b>Environment:</b> ",   geoami$MVG_NAME.extant, "<br>",
                  "<b>Coordinates:</b> ",   geoami$latitude, " : ",  geoami$longitude
                ),
                radius = 4,              # Adjust the radius size as needed
                fillColor = "burlywood", # Inside circle
                color =     "#ED8800",   # Choose a color for the circle markers #009FDF -agrfblue
                stroke = TRUE,           # border on circles                     #ED8800 -agrforange   
                fillOpacity = 0.5        # Adjust opacity
              ) %>%
              addCircleMarkers(
                data = umappicked(),
                lng = ~longitude,
                lat = ~latitude,
                popup = paste(
                  "<b>AMI Sample ID:</b> ", umappicked()$sample_id, "<br>",
                  "<b>Environment:</b> ", umappicked()$MVG_NAME.extant, "<br>",
                  "<b>Coordinates:</b> ", umappicked()$latitude, " : ", umappicked()$longitude
                ),
                radius      = 6,
                fillColor   = "#009FDF",
                color       = "#0090b0",
                stroke      = TRUE,
                fillOpacity = 0.5
              )
          })
          incProgress(1, detail = "UMAP completed.")  
        })
      
      # Render table with selected samples' metadata
      output$table_umap_ami <- renderDT({
        tabledata <- umappicked()
        if (nrow(tabledata) > 0) {
          selected_metadata <- merge(tabledata[, 1:2], amidataset[, 1:21], by.x = "ids", by.y = "ids", all.x = TRUE)
          datatable(selected_metadata, 

                    caption = 'Table with information for selected samples',
                    extensions = 'Buttons',
                    options = list(autoWidth = FALSE,
                                   lengthMenu = c(5, 50, 100, -1),
                                   scrollY = TRUE,
                                   scrollX = TRUE,
                                   columnDefs = list(list(visible = FALSE, targets = c(2:9,11:17))),
                                   paging = TRUE,
                                   searching = TRUE,
                                   fixedColumns = TRUE,
                                   ordering = TRUE,
                                   dom = 'Blfrtip',
                                   buttons = c('colvis', 'copy', 'csv', 'excel')))
        }
      })
      # Generate pie chart based on MVG_NAME.extant
      output$count_chart <- renderPlotly({
        selected_data <- umappicked()
        if (nrow(selected_data) > 0) {
          count_table <- selected_data %>%
            group_by(amidataset$MVG_NAME.extant[match(ids, amidataset$ids)]) %>%
            tally(name = "Count") %>%
            arrange(desc(Count))
          
          # Prepare colors based on mycolors object
          entity_names <- count_table[[1]]
          colors <- ifelse(entity_names %in% names(mycolors), mycolors[entity_names], "gray74")
          
          totalselectedsamples <- sum(count_table$Count);
          
          piefig <- plot_ly(
            labels = ~count_table[[1]],
            values = ~count_table[[2]],
            type = 'pie',
            marker = list(colors = colors),  # Set custom colors here
            hole = 0.3,
            textinfo = 'label+percent'
          ) %>%
            layout(
              autosize = TRUE,
              showlegend = FALSE,
              annotations = list(
                list(
                  x = 0.5, y = 0.5,  # Center of the donut
                  text = paste0("<b>", totalselectedsamples, "</b>"),  # Bold text
                  showarrow = FALSE,
                  font = list(size = 24)
                )
              )
            )
          
          piefig
          
        }
      });
      
      
      ##Raincloud for detected Detected_OTUs	or  Shannon_Index
      output$raincloud_plot <- renderPlot({
        selected_data <- umappicked()
        if (nrow(selected_data) > 0) {
          raintable <- selected_data %>%
            mutate(Group = "Selected") %>%
            bind_rows(
              amidataset %>%
                filter(!ids %in% selected_data$ids) %>%
                mutate(Group = "Not selected")
            ) %>%
            mutate( OTUs = amidataset$Detected_OTUs[match(ids, amidataset$ids)])
          
          ggplot(raintable, aes(x = factor(1), y = OTUs, fill = Group, color = Group)) +
            geom_rain(alpha = .5, rain.side = 'l',
                      boxplot.args = list(color = "black", outlier.shape = NA),
                      boxplot.args.pos = list(
                        position = ggpp::position_dodgenudge(x = -0.1, width = 0.1), width = 0.1
                      ), size = 1.5) +
            theme_classic() +
            scale_fill_manual(values = c("Selected"  = "#009FDF", "Not selected" = "#ED8B00")) +
            scale_color_manual(values = c("Selected" = "#009FDF", "Not selected" = "#ED8B00")) +
            guides(fill = 'none', color = 'none')
        }
      })
      
        
      
      
#      message("Spinner arrived to the end...")
      shinyjs::hide("spinner2") 


      }else{
      message("Batch predicted data is not existed");
      output$batchdata_message <- renderUI({
        HTML("<p style='font-size: 12px; color: red; font-weight: bold;'> <br> !!! STOPPED !!!<br></p>
              <p style='font-size: 10px;'>The batchdata with predicted geographical coordinates  does not exist.<br>
              You may need to run prediction by clicking [Predict with randomForest] button on the first tab [Predictions]. That will generates coordinates for the test batch and allow to integrate test samples with AMI dataset.</p>")
      })
      shinyjs::hide("spinner2") 
      }
    
    ### update report tab samplelist
    if (!is.null(mypredictions)) {
      updateSelectInput(session, "sample_id", 
                        choices = mypredictions$Sample,
                        selected = mypredictions$Sample[1])
    } else {
      updateSelectInput(session, "sample_id", 
                        choices = c("No data available"),
                        selected = "No data available")
    }
 
    ### Fuck me

    output$dynamic_download_button <- renderUI({
      req(input$sample_id)  # Ensure sample_id is selected
      downloadButton(
        outputId = "download_report",  # Static ID for consistency
        label = paste("Download Report for:   ", input$sample_id)
      )
    })
    
    # Download handler
    output$download_report <- downloadHandler(
      filename = function() {
        paste0("Report_", input$sample_id, ".html")  # Dynamic filename
      },
      content = function(file) {
        req(input$sample_id)  # Ensure sample_id is available
        print(paste("Rendering report for sample:", input$sample_id))
        
        # Define a temporary R Markdown file path
        temp_report <- "umap_2_html.Rmd"  # Directly use the file if it exists in your app directory
        
        # Render the R Markdown report
        rmarkdown::render(
          input = temp_report,  # Path to the RMD file
          output_file = file,   # Direct output to the provided location
        # intermediates_dir = "tmp/",
          intermediates_dir = "C:\\Users\\turakur\\OneDrive\ -\ Australian\ Genome\ Research\ Facility\ Ltd\\Documents\\CRC_TiME\\MicrobialLandScape\\tmp", 
          params = list(
            sample_id = input$sample_id  # Pass sample_id as a parameter
          ),
          envir = new.env(parent = globalenv())  # Ensure access to global environment
        )
      }
    )
    
    
  });
  
  



  shinyjs::enable("umap_plot_selected")
  
}



# Run the application
shinyApp(ui = ui, server = server)
